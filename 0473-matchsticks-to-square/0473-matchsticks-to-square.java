class Solution {
    // HashMap to store the pre-computed results...
    Map<Integer, Boolean> maskMemo = new HashMap<Integer, Boolean>();
    
    public boolean makesquare(int[] matchsticks) {
        int sum = 0;    // Summing all the matchsticks...
        for(int matchstick : matchsticks)
            sum += matchstick;
        if(sum % 4 != 0)    // If they can be split into four equal sides...
            return false;
        Arrays.sort(matchsticks);       // Sorting for faster calculation...
        int side = sum / 4;
        if(matchsticks[matchsticks.length-1] > side)
            return false;   // If largest stick is greater than the side length...
        return partitionIntoFour(matchsticks, 0, side, 4, 0);   // Function call...
    }

    public boolean partitionIntoFour(int nums[], int sum, int side, int edges, int mask) {
        if(edges == 1)  // If except last all edges are valid, then last is also valid...
            return true;
        if(maskMemo.containsKey(mask))      // If current subproblem is precomputed...
            return maskMemo.get(mask);
        if(sum == side)     // If a valid edge is found, reduce the edge count...
            return partitionIntoFour(nums, 0, side, edges-1, mask);
        // Traversing each stick...
        for(int i = 0; i < nums.length; i++) {
            // Using bitmask to store the chosen stick...
            int bit = 1 << i;
            // If the current stick is already taken or exceeds side length, skip it...
            if((mask & bit) != 0 || sum+nums[i] > side)
                continue;
            // Recursively check if four valid edges can be formed...
            if(partitionIntoFour(nums, sum+nums[i], side, edges, mask | bit)) {
                maskMemo.put(mask, true);       // Updating the memo...
                return true;
            }
        }
        maskMemo.put(mask, false);      // Update the memo...
        return false;       // If no valid combination is possible...
    }
}